## 1. Java-сервлеты. Особенности реализации, ключевые методы, преимущества и недостатки относительно CGI и FastCGI.
__Cервлет__ — это серверный сценарий, написанный на Java
### Особенности реализации
- Жизненный Цикл 

Сервлеты имеют жизненный цикл, управляемый контейнером сервлетов (веб-контейнером). Методы init(), service(), и destroy() основные в этом цикле.
- Потокобезопасность

Одному экземпляру сервлета могут одновременно обращаться несколько потоков. Это нужно учитывать для обеспечения потокобезопасности.
- Конфигурация

Можно настроить через аннотации или в web.xml.

### Ключевые методы

- `init()`: вызывается при инициализации сервлета.
- `doGet()`, `doPost()`: обрабатывают GET и POST запросы соответственно.
- `service()`: выбирает конкретный метод для обработки в зависимости от типа HTTP-запроса.
- `destroy()`: вызывается при завершении работы сервлета.

### Преимущества относительно CGI и FastCGI

- **Производительность**: Сервлеты более производительны, так как они работают в отдельных потоках на веб-контейнере. В CGI, для каждого запроса создается новый процесс, что тяжелее с точки зрения системных ресурсов.
- **Полноценный API**: Сервлеты имеют доступ к мощному Java API, включая возможности для работы с сетью, базами данных и т.д.
- **Портабельность**: Благодаря JVM, сервлеты могут работать на любой операционной системе без изменения кода.

### Недостатки относительно CGI и FastCGI

- **Стартовые затраты по ресурсам**: Сервлеты требуют больше памяти при инициализации по сравнению с FastCGI.
- **Возможны конфликты при параллельной обработке запросов**

## 2. Контейнеры сервлетов

**Контейнер сервлетов** — это часть веб-сервера, которая управляет жизненным циклом сервлетов, маршрутизацией запросов, и другими задачами.

### Жизненный цикл сервлета
1. **Загрузка класса сервлета**
2. **Создание экземпляра сервлета (отвечает веб-контейнер)**
3. **Инициализация**: Вызывается метод `init()`.
4. **Обработка запросов (service)**: Методы `doGet()`, `doPost()`, и т.д. вызываются в зависимости от типа запроса.
5. **Завершение**: Вызывается метод `destroy()`.

## 3. Диспетчеризация запросов в сервлетах. Фильтры сервлетов.

### Диспетчеризация запросов в сервлетах

- Сервлеты могут делегировать обработку запросов
  другим ресурсам (сервлетам, JSP и HTML-страницам).
- Диспетчеризация осуществляется с помощью
  реализаций интерфейса
  `javax.servlet.RequestDispatcher`.
- Два способа получения `RequestDispatcher` — через
  `ServletRequest` (абсолютный или относительный URL)
  и `ServletContext` (только абсолютный URL).
- Два способа делегирования обработки запроса —
  `forward` и `include`.

### Фильтр сервлетов
Сервлетный фильтр занимается пред- и постобработкой запроса до и после передачи ресурсу. 


Основой для формирования фильтров служит интерфейс `javax.servlet.Filter`, который реализует три метода:

`void init (FilterConfig config) throws ServletException;`

`void destroy ();`

`void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;` -
передает управление след. фильтру / ресурсу => возможна реализация последовательностей
фильтров для обработки одного и того же запроса.

## 4. HTTP-сессии

**Назначение**: Сохранение состояния между различными запросами от одного и того же пользователя, привязана к конкретному приложению

**Взаимодействие с сессией**: Сервлеты взаимодействуют с сессией через интерфейс `HttpSession`, позволяет идентифицировать клиента
при обработке множества HTTP запросов от него. Экземпляр создается при первом обращении и сохраняется опр. время.

``` java
HttpSession session = request.getSession();
session.setAttribute("username", "John");
```

**Способы передачи идентификатора сессии**: Cookies, добавление к URL, Hidden Form Fields. Если удалить - создастся новая сессия

## 5. Контекст сервлета - назначение, способы взаимодействия сервлетов с контекстом.
**Контекст сервлета - API, с помощью которого сервлет может взаимодействовать со своим контейнером.**

**Назначение**: Хранение данных, которые доступны всем сервлетам в приложении.

**Взаимодействие**: Сервлеты взаимодействуют с контекстом через интерфейс `ServletContext`.

``` java
ServletContext context = getServletContext();
context.setAttribute("globalData", "someValue");
```
*На каждом экземпляре JVM контейнером создается свой контекст*

## 6. JavaServer Pages (JSP)
**JSP страницы - текстовые файлы, содержащие статический HTML и JSP-элементы**
### Особенности

- **Внедрение Java-кода в HTML**: Возможность использовать Java-код внутри HTML-страницы.

### Преимущества и недостатки

- **Преимущества**: Удобство в создании динамических страниц, разделение бизнес-логики и представления, высокая производительность, платф.-назвис., Java API.
- **Недостатки**: Сложность поддержки и отладки, конфликты при || обработке запросов

### Область применения

- Генерация динамического HTML, создание простых веб-приложений.

## 7. Жизненный цикл JSP
1. **Трансляция JSP в код сервлета (.jsp -> .java)**
2. **Компиляция сервлета (.java -> .class)**
3. **Загрузка сервлета веб-контейнером**
4. **Создание экземпляра сервлета**
5. **Инициализация**: Вызывается метод `init()`.
6. **Обработка запросов (_jspService)**: Методы `doGet()`, `doPost()`, и т.д. вызываются в зависимости от типа запроса.
7. **Завершение**: Вызывается метод `destroy()`.

## 8. Структура JSP-страницы. Комментарии, директивы, объявления, скриптлеты и выражения.
### Комментарии (3 типа):
1. <%-- Это JSP-комментарий, виден только в JSP коде, не виден в response и сервлете --%>
2. `<!-- Это HTML комментарий, появится в response -->`
3. <% 

    /* Это Java коммент, появится в сервлете, 
       но `не` появится в response */

    %>

### Директивы

**Управляют процессом трансляции страницы в сервлет**

Page Directive: Управляет общим поведением страницы.

```jsp
<%@ page language="java" contentType="text/html" %>
```
Include Directive: Включает содержимое другого файла.

```jsp
<%@ include file="header.jsp" %>
```
Taglib Directive: Для подключения пользовательских или стандартных тегов.
```jsp
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
```

### Объявления
**Объявления JSP позволяют задавать переменные, методы, внутренние классы и так далее. Существуют на протяжении всего жизенного цикла JSP**

```jsp
<%! int counter = 0; %>
<%! int increment() { return counter++; } %>
```

### Скриптлеты

**Для задания Java кода, который будет выполняться при обработке запросов (при вызове _jspService)**
```
<% int x = 10; %>
```

### Выражения

**Для вывода результат вычисления выражений**
```
Текущее время: <%= new java.util.Date() %>
```

## 9. Правила записи Java-кода внутри JSP. Стандартные переменные, доступные в скриптлетах и выражениях.

### Правила записи Java-кода
- Код должен быть заключен в соответствующие теги (<% %> для скриптлетов, <%= %> для выражений).
- Использование полноценных Java-конструкций (if-else, loops) допустимо внутри скриптлетов.

### Стандартные переменные:
- `request`: объект HttpServletRequest
- `response`: объект HttpServletResponse
- `out`: объект JspWriter
- `session`: объект HttpSession
- `application`: объект ServletContext
- `config`: ServletConfig
- `page`: java.lang.Object
- `exception`: Throwable
- `pageContext`: jsp.PageContext

## 10. Bean-компоненты и их использование в JSP.

JavaBeans — классы в языке Java, написанные по определённым правилам. Они используются для объединения нескольких объектов в один для удобной передачи данных.
Представляют собой переиспользуемые куски кода, обычно инкапсулирующие некую бизнес-логику.

**Правила описания:**

- Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.
- Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов.
- Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.

### Bean и JSP:
Специальные теги JSP позволяют легко интегрировать Beans в JSP-страницы.
```
<jsp:useBean id="user" class="com.example.User"/>
<jsp:setProperty name="user" property="name" value="John"/>
<jsp:getProperty name="user" property="name"/>
```

## 11. Стандартные теги JSP. Использование Expression Language (EL) в JSP.

### Стандартные теги JSP:

- `<jsp:useBean>`: Создает или восстанавливает bean-компонент.
- `<jsp:setProperty>` и `<jsp:getProperty>`: Устанавливают и получают свойства bean-компонентов.
- `<jsp:include>`: Включает содержимое другой страницы или ресурса.
- `<jsp:forward>`: Перенаправляет запрос на другую страницу или ресурс.


### Standard Tag Library (JSTL)
Хотя это не "стандартные" JSP-теги, JSTL часто используется в JSP для предоставления дополнительных функций через теги, такие как циклы, условные операторы и интернационализация. Например:

- `<c:out>`: Выводит текст.
- `<c:forEach>`: Цикл.
- `<c:if>`: Условный оператор.

``` jsp
<html>
  <body>
    <jsp:include page="header.jsp"/>
    <c:out value="${message}"/>
  </body>
</html>
```

### Expression Language (EL):
Expression Language (EL) в JSP предназначен для упрощения доступа к данным, хранящимся в различных областях (scopes), таких как request, session, application и так далее. 

EL обеспечивает более чистый и читаемый способ доступа к атрибутам и параметрам в этих областях по сравнению с традиционными JSP-скриптлетами.
Также имеет компактный синтаксис для обращения к массивам, коллекциям и тд.

Доступ к атрибутам
- `${requestScope.attributeName}`
- `${sessionScope.attributeName}`
- `${applicationScope.attributeName}`

Операции и вычисления
- `${2 + 2}` — результат будет 4.
- `${'Hello ' + 'World'}` — результат будет Hello World.
  
Доступ к свойствам объекта (JavaBean)

`${user.name}` — доступ к свойству name объекта user.

## 12. Параметры конфигурации JSP в дескрипторе развёртывания

Java веб-приложения используют файл дескриптора развертывания для определения какие URL будут передаваться определенному сервлету, какие URL требуют аутентификации и др. 

Этот дескриптор развертывания называется web.xml и находится в WAR приложения в WEB-INF/ директории. Web.xml – часть стандарта сервлета для веб-приложений.

Конфигурация находится внутри элемента jsp-config
- `<welcome-file-list>`: Устанавливает начальную страницу веб-приложения.
- `<servlet>` и `<servlet-mapping>`: Описывают настройки сервлетов.
- `<context-param>`: Общие параметры для всего веб-приложения.

## 13. Шаблоны проектирования и архитектурные шаблоны

**Архитектурные шаблоны:**

- MVC (Model-View-Controller): Разделяет логику приложения, UI и управление пользовательским взаимодействием.

- MVVM (Model-View-ViewModel): Расширение MVC, добавляет ViewModel для упрощения двустороннего связывания между View и Model.

- RESTful: Архитектура, основанная на принципах REST, для создания распределенных систем.

- Microservices: Разделяет приложение на множество независимых, небольших служб, которые могут разрабатываться, развертываться и масштабироваться независимо.

- Layered Architecture: Разделяет приложение на слои, такие как Presentation, Business и Data Access Layer.

**Основные шаблоны проектирования:**

- Factory Method: определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.;
- Abstract Factory: Предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.
- Builder: Отделяет конструирование сложного объекта от его представления.
- Prototype: Создает новый объект путем копирования существующего объекта.
- Singleton: Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру.

## 14. Архитектура веб-приложений. Шаблон MVC.

- **Model**: Содержит бизнес-логику. Предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность (не зависит от представления, не знает как данные визуализировать) и контроллера (не имеет точек взаимодействия с пользователем).
- **View**: Отображение данных, получение необходимых данных из модели и отправляет их пользователю
- **Controller**: Обрабатывает запросы и управляет переходами, обеспечивает «связи» между пользователем и системой

#### Архитектурные модели Model 1 и Model 2

- **Model 1**: Все обрабатывается на уровне JSP. Не рекомендуется для крупных проектов из-за отсутствия разделения логики; 
за обработку данных и представление отвечает один и тот же компонент 

- **Model 2 (MVC)**: Рекомендуется для больших проектов. Использует сервлеты в качестве контроллеров и JSP для представления.

#### Реализация на платформе Java EE

- **Model 1**: Просто JSP страницы, обработка данных и бизнес-логика встроены прямо в JSP.

- **Model 2**: Использует JavaBeans или EJB для бизнес-логики, сервлеты в качестве контроллеров и JSP для представления. Поддерживает разделение логики и представления, что облегчает разработку и тестирование.

Фреймворки для реализации: `Apache Struts`, `Apache Velocity`, `JSF`


